# 概略

* マッチング処理って、共通化をうまく使うと速くなるのでは？という話
* 難しくしたくないので、２階層化だけで考える
  * ROOT >> LEAF

# 先に考えておかなきゃいけないこと

* 見え方が異なるのでモデル点は
  * (0 - 30)は、本来確実に見えると仮定: CORE
  * (30 - 45+α)は、半分見えると仮定: SUB
* COREはそのままカウント
* SUBもそのままカウントするが、しきい値が甘い感じで良いか
* SUBが全部見えているからといって、スコアが1.0を超えるのは避けないといけない
  * max(SUB)はLEAFにいかないとわからないな。。。
* つまり、ROOTにSUBは存在させたくない？
  * 45度傾いているのが軒並み遅くなってしまう
* 仕方がないので、COREとSUBは変数を分けて考える
  * COREとSUBはカウントをわけなければいけないことに注意
  * このへんはPPFの方が向いているのかー
  
# COREとSUBと階層化について検討

* ケーススタディで考える
* core_featureが10点、sub_featureが10点あったとする
* 閾値が80%
* このときの考え方は、(core_feature数 + min(sub_feature, 5))が15 * 0.8を超えていれば良いということになる
* この方針で進んでよいのだろうか？
  * core_featureが20点のときは、4点損失したタイミングで投票のループを打切ることができる
  * 逆にケーススタディでは、
	* core_featureが3点損失で打ち切り
	* そうでないケースが遅くなる
  * 階層化との相性も考えたい
	* 例えばROOTでcoreが5点、subが5点共通化されたとしよう。順番としては
	  * @ROOT coreが3点損失で打切り
	  * @ROOT subの打切り方法
		* 例えばcoreが2点損失のとき(あと1点損失で打切り)
		  * 残りのcore特徴点5点が全てあったケースを考えると、5点全て無くても打ちきれない！
		  * まあ、処理の共通化という意味で、意味はあるのか。
			* LEAFで同じ投票が繰り返されることはない
	* つまり共通化の意味がほとんどなくなってしまうので、相性が良くない
* しかし結局、45度傾いているケースを救おうとするとどうしようもないのか？
  * そんなことはない。候補が少し増えてしまうが、見えの違いを候補を増やすことで解消できるだろう
* 方針が決まらない
  * 少し気持ち悪いが▲ワークがあったときに、片面しか見えない状態でマッチングしなければいけないケースが多々あるので、両方見えているときに両方マッチするというのは諦める？
  * (-51 ~ +51), (-51 ~ +30), (-30 ~ +51)で３つの見えをカバーすれば良いだろう
* 45度までは確実に見える方針で行く?多分普通これは保証できる
  * まあ、パラメータであっても良いのか
  * 見えでマッチングするという意味では、距離画像でやったほうが良いのは変わらないなー

## 暫定方針

* とりあえずお試しでは、(-51 ~ +51)まで全てCOREだと思って処理する
  * この51はパラーメータにしておく


# 処理に必要な変数

* root_core_zbin
* leaf_core_zbin
* root_sub_zbin
* leaf_sub_zbin
* ROOT_INFO
  * num_core
  * feature_arry
  * thre
  * num_leaf
  * leaf_arry
* LEAF_INFO
  * offset
  * sum_feature
  * feature_arry
  * sum_thre
* ROOT_RESULT
* LEAF_RESULT

# 検出時の処理の流れ

* ROOT_INFOの決定
  * ix, iyのスライディングウィンドウに対して
	* for ii in num_feature
	  * feature_arry[ii].xとfeature_arry[ii].yを使って、密ボクセルにアクセス
	  * root_zbinに投票
	* max(root_zbin)がしきい値を超えていたら
	* for jj in num_leaf
	  * leaf_zbinにコピー
	  * for ii in num_feature
		* leaf_zbinに投票

# モデル教示時の処理の流れ

* COREが3点以上の候補を集めて
  * まずは、特徴点の各候補における分布で分類
	  * まずは、主成分分析で分類
	  * 分類の中で
		* もっとも特徴点の多い候補を取得
		  * この原点がROOTの原点になる
		  * 各候補で、もっともマッチするoffsetを取得
	    * bit演算&グリードで適当にleafを計算

* SUBが3点以上の候補を集めて
  * SUB特徴点を使って、COREのときと同じ処理を行う

* 残ったのは、LEFTとして

そもそも、COREとSUBで数え方が違う。。。COREはスコアが１あがるがSUBは0.5しか上がらない。
