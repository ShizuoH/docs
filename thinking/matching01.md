# 概略

* マッチング処理って、共通化をうまく使うと速くなるのでは？という話
* 難しくしたくないので、２階層化だけで考える
  * ROOT >> LEAF

# 先に考えておかなきゃいけないこと

* 見え方が異なるのでモデル点は
  * (0 - 30)は、本来確実に見えると仮定: CORE
  * (30 - 45+α)は、半分見えると仮定: SUB
* COREはそのままカウント
* SUBもそのままカウントするが、しきい値が甘い感じで良いか
* SUBが全部見えているからといって、スコアが1.0を超えるのは避けないといけない
  * max(SUB)はLEAFにいかないとわからないな。。。
* つまり、ROOTにSUBは存在させたくない？
  * 45度傾いているのが軒並み遅くなってしまう
* 仕方がないので、COREとSUBは変数を分けて考える
  * COREとSUBはカウントをわけなければいけないことに注意
  * このへんはPPFの方が向いているのかー
  
# COREとSUBと階層化について検討

* ケーススタディで考える
* core_featureが10点、sub_featureが10点あったとする
* 閾値が80%
* このときの考え方は、(core_feature数 + min(sub_feature, 5))が15 * 0.8を超えていれば良いということになる
* この方針で進んでよいのだろうか？
  * core_featureが20点のときは、4点損失したタイミングで投票のループを打切ることができる
  * 逆にケーススタディでは、
	* core_featureが3点損失で打ち切り
	* そうでないケースが遅くなる
  * 階層化との相性も考えたい
	* 例えばROOTでcoreが5点、subが5点共通化されたとしよう。順番としては
	  * @ROOT coreが3点損失で打切り
	  * @ROOT subの打切り方法
		* 例えばcoreが2点損失のとき(あと1点損失で打切り)
		  * 残りのcore特徴点5点が全てあったケースを考えると、5点全て無くても打ちきれない！
		  * まあ、処理の共通化という意味で、意味はあるのか。
			* LEAFで同じ投票が繰り返されることはない
	* つまり共通化の意味がほとんどなくなってしまうので、相性が良くない
* しかし結局、45度傾いているケースを救おうとするとどうしようもないのか？
  * そんなことはない。候補が少し増えてしまうが、見えの違いを候補を増やすことで解消できるだろう
* 方針が決まらない
  * 少し気持ち悪いが▲ワークがあったときに、片面しか見えない状態でマッチングしなければいけないケースが多々あるので、両方見えているときに両方マッチするというのは諦める？
  * (-51 ~ +51), (-51 ~ +30), (-30 ~ +51)で３つの見えをカバーすれば良いだろう
* 45度までは確実に見える方針で行く?多分普通これは保証できる
  * パラメータであるべきかもしれない
  * 見えでマッチングするという意味では、距離画像でやったほうが良いのは変わらない
* 変にCOREとSUBにわけるのは良くないだろう
	* 傾きに応じて、$a = 1$ [tex:cos(\\theta)]$$b=1$$
	* $$a_{ij} \ (i \neq j)$$
	```math
		c = 1
	```

和の公式
$$ \sum\_{k=1}^n k = \frac{1}{2}n(n+1) $$
を計算する関数を C++ で実装せよ。

## 暫定方針

* とりあえずお試しでは、(-51 ~ +51)まで全てCOREだと思って処理する
  * この51の値は、パラーメータにしておく
  * 閾値の設定で救えるかなと期待している

# 処理に必要な変数

* root_zbin
* leaf_zbin
* ROOT_INFO
  * UBYTE num_feature
  * IVEC3 feature_arry
  * UBYTE thre
  * LONG num_leaf
  * LEAF_INFO leaf_arry
* LEAF_INFO
  * IVEC2 offset
  * LONG sum_feature
  * IVEC3 feature_arry
  * UBYTE sum_thre
* ROOT_RESULT
  * root_num
* LEAF_RESULT

# 検出時の処理の流れ

* for root
  * for ix, iy
	* for ii in num_feature
	  * feature_arry[ii].xとfeature_arry[ii].yを使って、密ボクセルにアクセス
	  * feature_arry[ii].zを使用して、root_zbinに投票
	* max(root_zbin)がしきい値を超えていたら
	* for jj in num_leaf
	  * leaf_zbinにコピー
	  * for ii in num_feature
		* leaf_zbinに投票

# 候補の共通化

* まずは、各候補における特徴点の分布で分類
  * 主成分分析でクラス分け
	  * クラスの中で
		* a. もっとも特徴点の多い候補を取得
		  * この原点がROOTの原点になる
		  * 各候補で、もっともマッチするoffsetを取得
	    * bit演算&グリードで適当にleafを計算
		* 10マッチ共通化できなかったら終了
		* aに戻る
	  * 残った候補を、階層化しない方法で



